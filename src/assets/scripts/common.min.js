gsap.registerPlugin(ScrollTrigger);

window.uxgFn = {
  ...window.uxgFn, // 혹시 있을지 모르는 uxgFn 업데이트

  debounce(func, delay) {
    let timeoutId;
    const time = delay ? delay : 200;
    return function () {
      const context = this;
      const args = arguments;
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        func.apply(context, args);
      }, time);
    };
  },

  watch(options) {
    // https://caniuse.com/?search=MutationObserver 브라우저 낮은 버전 + Opera Mini 에선 불가능
    if (options.el) {
      options.el =
        typeof options.el === "string"
          ? document.querySelector(options.el)
          : options.el;
    }
    const opt = {
      el: document.body, // - DOM 감시 대상 엘리먼트. default : document.body.
      config: { childList: true, subtree: true }, // - Mutation Observer의 설정. default : { childList: true, subtree: true }.
      console: false, // - 변화를 콘솔에 출력할지 여부. default : false.
      callback() {}, // - DOM 변화가 감지될 때 실행되는 콜백 함수. default : 기본 동작 콜백.
      ...options,
    };

    setTimeout(() => {
      const observer = new MutationObserver((mutationsList) => {
        for (const mutation of mutationsList) {
          if (mutation.type === "childList") {
            if (opt.console) {
            }
            opt.callback(mutation);
          }
        }
      });
      observer.observe(opt.el, opt.config);
    });
  },
  selectBox: {
    close(option) {
      const _option = {
        ...option,
      };

      const $el =
        typeof _option.$el === "string"
          ? document.querySelector(_option.$el)
          : _option.$el;
      const selectBox = $el.nextElementSibling;
      $el["isOpen"] = false;
      $el.classList.remove("active");
      selectBox.classList.remove("active");

      if (this.afterClose) {
        this.afterClose();
      }
    },
    afterClose($fn) {
      if ($fn) {
        $fn();
      }
    },
    open(option) {
      const _option = {
        ...option,
      };

      const $el =
        typeof _option.$el === "string"
          ? document.querySelector(_option.$el)
          : _option.$el;
      const selectBox = $el.nextElementSibling;
      $el["isOpen"] = true;
      $el.classList.add("active");
      selectBox.style.display = "block";
      setTimeout(() => {
        selectBox.classList.add("active");
      });
    },
  },
  popup: {
    close(option) {
      const _option = {
        ...option,
      };

      const $el =
        typeof _option.$el === "string"
          ? document.querySelector(_option.$el)
          : _option.$el;
      $el["isOpen"] = false;
      $el.classList.remove("active");

      setTimeout(() => {
        $el.style.display = "none";
        if (_option.afterClose) {
          _option.afterClose();
        }
      }, 50);
    },
    open(option) {
      const _option = {
        ...option,
      };

      const $el =
        typeof _option.$el === "string"
          ? document.querySelector(_option.$el)
          : _option.$el;
      $el["isOpen"] = true;
      $el.style.display = "flex";
      setTimeout(() => {
        $el.classList.add("active");
      }, 50);
    },
  },
};

// Loaded for Public Common ( Dom 생성후 이미지 포함 X ) - 개발이 비동기 안하면 여기에
document.addEventListener("DOMContentLoaded", () => {
  if (document.querySelectorAll(".ui-button-select")) {
    const btns = document.querySelectorAll(".ui-button-select");
    btns.forEach(($el, idx) => {
      const selectBox = $el.nextElementSibling;
      $el["isOpen"] = false;
      let isInit = false;
      $el.addEventListener("click", () => {
        isInit = true;
        if ($el["isOpen"]) {
          uxgFn.selectBox.close({ $el });
        } else {
          uxgFn.selectBox.open({ $el });
        }

        if (!isInit) {
          selectBox.addEventListener("transitionend", () => {
            if ($el["isOpen"]) {
              selectBox.style.display = "none";
            }
          });
          selectBox.querySelectorAll("button").forEach(() => {});
        }
      });
    });
  }

  if (document.querySelector(".ui-background-motion")) {
    const el = document.querySelectorAll(".ui-background-motion");
    el.forEach((element) => {
      const createBg = document.createElement("div");
      createBg.classList.add("bg");
      element.appendChild(createBg);

      element.addEventListener("mouseenter", (event) => {
        createBg.style.left = event.layerX + "px";
        createBg.style.top = event.layerY + "px";
        createBg.classList.add("active");
      });
      element.addEventListener("mouseleave", (event) => {
        createBg.style.left = event.layerX + "px";
        createBg.style.top = event.layerY + "px";
        createBg.classList.remove("active");
      });
    });
  }

  if (document.querySelector(".ui-count-up")) {
    const countElement = document.querySelectorAll(".ui-count-up");
    countElement.forEach(($el) => {
      ScrollTrigger.create({
        trigger: $el,
        start: "top bottom-=0%",
        markers: true, // 스크롤 트리거를 시각적으로 표시 (테스트용)
        onEnter: () => {
          const totalCount = Number($el.dataset.count);
          const duration = 2000;
          const interval = (totalCount / duration) * 10;
          let currentCount = 0;
          console.log(interval);
          function countUp() {
            if (currentCount <= totalCount) {
              $el.textContent = currentCount.toLocaleString();
              currentCount = parseInt(currentCount + interval);
              setTimeout(countUp, 5);
            } else {
              console.log("??");

              const numberWithoutCommas = $el.textContent.replace(/,/g, "");
              const parsedNumber = parseInt(numberWithoutCommas);
              console.log(parsedNumber);
              if (parsedNumber <= totalCount) {
                console.log("????");
                $el.textContent = parseInt(totalCount).toLocaleString();
              }
            }
          }

          countUp();
        },
      });
    });
  }

  if (document.querySelector(".btn-menu")) {
    const btn = document.querySelector(".btn-menu");
    const menu = document.querySelector(".mo-menu");
    btn.addEventListener("click", () => {
      menu.style.display = "block";
      setTimeout(() => {
        menu.style.left = 0;
      });
    });
  }

  if (document.querySelector("[data-scroll]")) {
    const btns = document.querySelectorAll("[data-scroll]");
    btns.forEach(($el) => {
      $el.addEventListener("click", () => {
        const top =
          $el.dataset.scroll === ".section-area.marketing"
            ? document.querySelector($el.dataset.scroll).offsetTop - 150
            : document.querySelector($el.dataset.scroll).offsetTop;
        window.scroll({
          top,
          behavior: "smooth",
          duration: 500,
        });
      });
    });
  }
});

// Loaded for Public Common ( 모든 리소스 로드후 이미지,js,css ) - 개발이 비동기로드후 필요하면 여기에
window.addEventListener("load", function () {
  // Update
  if (document.querySelector(".ui-stagger-group")) {
    const groups = document.querySelectorAll(".ui-stagger-group");

    groups.forEach((group, idx) => {
      if (group.classList.contains("no-scroll")) {
        const groupChildren = group.querySelectorAll(".ui-stagger-el");
        gsap.to(groupChildren, {
          duration: 0.0, // 애니메이션 지속 시간
          stagger: 0.05, // 요소들 간의 지연 시간 설정
          onCompleteAll: (_idx) => {
            groupChildren[_idx].classList.add("active");
          },
        });
      } else {
        console.log(group.dataset.y);
        ScrollTrigger.create({
          trigger: group,
          start: `top bottom-=${group.dataset.y ? group.dataset.y : 20}%`,
          markers: true, // 스크롤 트리거를 시각적으로 표시 (테스트용)
          onEnter: () => {
            const groupChildren = group.querySelectorAll(".ui-stagger-el");
            gsap.to(groupChildren, {
              duration: 0.0, // 애니메이션 지속 시간
              stagger: 0.05, // 요소들 간의 지연 시간 설정
              onCompleteAll: (_idx) => {
                groupChildren[_idx].classList.add("active");
              },
            });
          },
        });
      }
    });
  }
  uxgFn.watch({
    callback(param) {},
  });
});

// Resize for Public Common
window.addEventListener(
  "resize",
  uxgFn.debounce(() => {})
);
